---
title: "MuJoCoによるロボットシミュレーション例"
emoji: "😊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["MuJoCo", "python", "robot"]
published: true
---

## はじめに

以前MuJoCoを使用する授業のTAをしているときに、ネット上の実装例が少なく、フリー課題で苦労している学生が多くいました。そこで、他のMuJoCoの学習者にも役立ててもらおうと、いくつかの実装例を紹介したいと思います。

[簡単！実践！ロボットシミュレーション](https://www.morikita.co.jp/books/mid/084691)内で紹介されているものを中心に、MuJoCoでの実装とその説明、動作例などを示します。ここでは、実装を中心に紹介するため、より詳細な設定や機能などについては[公式ドキュメント](https://mujoco.readthedocs.io/en/stable/overview.html)や[こちらのQiita記事](https://qiita.com/Yayoi-Habami/items/1bf5a3e05b1516a90381)を参照してください。

## 環境

* macOS 15.4.1
* Python 3.13.3
* MuJoCo 3.2.7

MuJoCoはバージョンアップによって破壊的な変更が加わることもあります。最新バージョンで動作しない場合は、上記のバージョンを使用してみてください。

## 基本事項

MuJoCoではモデルをXML形式で記述します。シミュレーションの表示はライブラリで用意されているものを利用したり、画像出力したものを表示したりなど様々な方法があります。今回はインタラクティブな動作や表示のカスタマイズを可能にするため、[mujoco_viewer](https://github.com/rohanpsingh/mujoco-python-viewer)を元にしたビューワーを使用しました。

:::message
被っている部分については説明を省略している場合もあります。ご了承下さい。
:::

## 実装例

### 共通設定

MuJoCoでは、別のモデルファイルをインポートできます。共通の設定を記述したファイルを作成し、それぞれのモデルファイルでそのファイルをインポートする、という形で使用されることが（見ている中では）多いです。

以下に今回使用した共通の設定ファイルを示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/assets/shared.xml

2〜13、23〜28行目は設定を記述しています。
15〜21行目は各要素のデフォルト設定を記述しています。モデルを定義するときにここでの設定が使用されます。ただ、同じ項目をモデルファイルで設定している場合は上書きされます。また、17行目のようにクラスを定義すると、クラス使用時のみデフォルト設定が有効になります。
30〜34行目はシミュレーション空間上に設置する床と照明の設定を記述しています。

以下には、それぞれで使用するビューワーの元となるクラスの定義を示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/src/viewer.py

[mujoco_viewer](https://github.com/rohanpsingh/mujoco-python-viewer)で定義されているクラスを継承し、新たにモデルに合わせたカメラ位置の変更や表示の変更ができるようにしています。
Viewerをさらに継承し、モデルや制御ごとに_key_callback関数や_callback関数をカスタマイズして使用することを想定しています。

### ホッピングロボット

ここではホッピングロボットの実装について紹介します。上下の矢印キーを押すことで下の動画のようにジャンプします。

![Hopper](/images/mujoco-example/hopper.gif)

モデルファイルを以下に示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/assets/hopper.xml

2行目で上でも説明した共通の設定ファイルを読み込んでいます。
4〜16行目でシミュレーション空間に設置するホッピングロボットの定義をしています。足を2つの円柱（7，9行目）・頭部を球（12行目）で構成し、足はスライダージョイントで接続されています（10行目）。
19行目でスライダージョイントを動かすためのアクチュエータを定義しています。

<!-- textlint-disable ja-spacing/ja-space-between-half-and-full-width -->

:::details 詳細な説明
5行目では、全体のボディの基準を定義しています。今回は、空中に浮かせた状態から始めるために `z = 0.5` としています。
6行目では、全体のボディと環境が固定されないことを明示しています。
7行目では、下側の足の定義をしています。`fromto="x1 y1 z1 x2 y2 z2"` とすることで、座標 `(x1, y1, z1)` と座標 `(x2, y2, z2)` をつなぐ円柱を作成できます。sizeでは半径を設定しています。posとsizeで起点と高さ・半径を設定する方法もありますが、こちらの方法は向きを考えなくてすむので楽だと思います。
8行目では、上側の足から上のボディの位置を定義しています。MuJoCoでは子の位置姿勢は親からの相対的な位置姿勢で考えます。今回は、下側の足から少し上に設定しています。
9行目では、下側の足と同じように上側の足を定義しています。わかりやすさのために色は変えています。
10行目では、下側と上側の足をつなぐジョイントを定義しています。今回は、スライダージョイントを使用し、移動範囲を制限しています。
11行目では、8行目と同じように頭部のボディの位置を定義しています。
12行目では、頭部を球で作成しています。
19行目では、スライダージョイントを動かすためのアクチュエータを定義しています。ギア比を1000に設定しています。この値は、適当に試行錯誤して決めました。
:::

<!-- textlint-enable ja-spacing/ja-space-between-half-and-full-width -->

以下に実行するPythonファイルを示します。このファイルを実行すると、上の動画のように動作します。

https://github.com/maki8maki/MuJoCoExample/blob/main/src/hopper.py

5行目で読み込むMJCFファイルのパス、7〜12行目でカメラ位置の設定を指定しています。
15〜31行目でホッピングロボット用のビューワークラスを定義しています。19〜26行目が主要部分で、_key_callback関数を上書きしています。上下矢印キーが押されるとスライダージョイントのアクチュエータに力を加えます。`self.data` は `MjData` 型です。`self.data.ctrl` はアクチュエータに与える値のリストとなっており、アクチュエータを定義した順番とインデックスが対応します。今回は、アクチュエータが1つのみなので、インデックス0に値を代入します。

### 2輪差動駆動ロボット

ここでは2輪差動駆動ロボットの実装について紹介します。2輪差動駆動ロボットとは2輪の駆動輪とキャスターなどの補助輪で移動するロボットです。以下の動画が動作例となっています。上下の矢印キーで前後に移動し、左右の矢印キーで回転します。（摩擦の調整前のため、タイヤが空回りしています。）

![Wheel](/images/mujoco-example/wheel.gif)

モデルファイルを以下に示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/assets/wheel.xml

4~22行目でロボットの定義をしています。ボディ（7行目）、キャスター（9~12行目）、左右のタイヤ（13〜20行目）で構成されています。8行目にボディを追跡するカメラを定義しており、ロボットの移動に合わせてカメラも動きます。
24〜27行目でアクチュエータの定義をしており、左右のタイヤそれぞれの軸に回転方向の力を加えます。

<!-- textlint-disable ja-spacing/ja-space-between-half-and-full-width -->

:::details 詳細な説明
5行目は全体の位置の基準を設定しています。タイヤの分だけ浮かせています。
7行目はボディを定義しており、今回は直方体としています。
8行目はカメラを定義しています。`mode="trackcom"` とし、ボディを追従するように設定しています。
9〜11行目で補助輪であるキャスターを定義しています。形状を球とし、ballジョイントを設定することで、自由回転するようにしています。
13〜16行目で左側の駆動輪を定義しています。形状はシリンダです。タイヤが空回りしないように `friction="3.0` と設定しています。MuJoCoで設定できる摩擦のパラメータは滑り摩擦、ねじれ摩擦、転がり摩擦ですが、このように指定すると、滑り摩擦のみが変更されて残りはデフォルト値が使用されます。今回は空回りの防止なので、滑り摩擦のみを大きくしています。実際のロボットの動作を再現する場合には、重量を適切に設定した上で、使用する床やタイヤの材質に合わせた摩擦設定が必要です。ジョイントはhingeジョイントを使いました。
右側の駆動輪は左側と基本的に同じです。
24〜26行目で左右の駆動輪を動かすためのアクチュエータを定義しています。
:::

<!-- textlint-enable ja-spacing/ja-space-between-half-and-full-width -->

以下に実行するPythonファイルを示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/src/wheel.py

19〜41行目でキーボードに関する動作を定義しています。
20〜23行目でタイヤの軸に加える力の大きさを定義しています。キーが押されているときは1.0、そうでないときは0.0としています。
以降の部分で矢印キーに応じた力のかけ方を定義しています。上矢印キーでは両輪に正の方向、下矢印キーでは両輪に負の方向の力を与えます。左右矢印キーでは左右のタイヤに反対方向の力を与え、車体が回転するようにしています。今回、両輪の中心を結んだ線と重心が交わらないため、その場で回転するにはより複雑な制御が必要です。

### オムニタイヤロボット

ここではオムニタイヤロボットの実装を紹介します。
オムニタイヤとはタイヤの外周にローラーがついており、軸方向の摩擦が小さいタイヤです。[こちらのサイト](https://www.note.suzakugiken.jp/?p=50)のイラストがわかりやすいかもしれません。オムニタイヤをつけたロボットはこの特性から全方向に移動可能です。
以下の動画は動作例です。上下左右の矢印での方向に移動し、A・Sキーで左回転や右回転します。矢印キーでの移動はロボットの向きに関係なく、世界座標での方向にしたがって移動するようにタイヤを動かしています。

![Omni](/images/mujoco-example/omni.gif)

モデルファイルを以下に示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/assets/omni.xml

4〜27行目でロボットの定義をしています。ボディ（7行目）、タイヤ（11〜25行目）で構成されています。ボディに追従するカメラや前方を示すためのマークなども定義しています。
29〜34行目ではアクチュエータを定義しています。4つのタイヤそれぞれに回転方向の力を加えます。
36〜42行目ではセンサーを定義しています。各タイヤの回転速度とボディの角速度を取得します。

<!-- textlint-disable ja-spacing/ja-space-between-half-and-full-width -->

:::details 詳細な説明
7行目でボディの定義をしています。
8行目はボディに追従するカメラを定義しています。
9行目はロボットの前方を示すマークを定義しています。このロボットは対称な形をしているためつけているだけなので、必須ではありません。
10行目はセンサーを取り付ける場所を定義しています。
11〜25行目でタイヤの定義をしています。`replicate` で繰り返しの設定ができます。`count` で繰り返し回数、`euler` で1回あたりの回転量を指定します。ここでは、z軸周りに90度ずつ4回回転させることで、タイヤを配置しています。13・14行目でタイヤ本体、15行目でボディに対するジョイントを定義しています。
16〜23行目では各タイヤに対してオムニタイヤを模擬するための球状の物体をタイヤの周囲に配置しています。18・19行目で球を定義しています。20・21行目でタイヤに対するジョイントを定義しています。このジョイントによって球はタイヤの軸方向に自由に回転し、オムニタイヤのような機能を果たします。球の回転を滑らかにするため、ジョイントの抵抗に関するパラメータをゼロにしています。
29〜34行目でアクチュエータの定義をしています。ここではreplicateを使用できないため、1つ1つ定義しています。
37〜40行目でタイヤの各軸の速度を測定するセンサを定義しています。また、41行目でボディの角速度を測定するジャイロセンサを定義しています。
:::

<!-- textlint-enable ja-spacing/ja-space-between-half-and-full-width -->

以下に実行するPythonファイルを示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/src/omni.py

22行目ではロボットの角度を初期化しています。また、23行目では各タイヤに与える力を初期化しています。
24行目ではタイヤの角速度の制御に使用するPIDコントローラーを定義しています。[simple-pid](https://simple-pid.readthedocs.io/en/latest/)を使用しています。パラメータは適当に決めています。このコントローラーはタイヤの停止のみに用います。
26・27行目ではロボットの角度を更新する関数を定義しています。ジャイロセンサから取得できるz軸周りの角速度にステップ時間を掛けたものを前周期の角度に足しています。
29〜33行目では現在のロボットの角度から各タイヤが出すべき力を計算する関数です。引数の `force` は出したい力（同じ方向のタイヤに力を与えるため実際はこの値の2倍）、`global_dir` は世界座標における出したい力の方向を表します。`global_dir` とロボットの現在の角度からロボット座標における出したい力の方向を計算し、それに基づいて各タイヤに分配する力を計算します。
35〜40行目で力を入力するユーティリティ関数を定義しています。タイヤに入力する力が小さいときにはPIDコントローラーを用いてタイヤを停止させるように制御します。これによってロボットが惰性で動き続けることを避けられます。
42〜66行目ではキーが押されたときの動作を定義しています。43〜46行目でキーが押された、押され続けているとき以外は `FORCE` を0.0とし、押すのをやめたときにロボットが停止するようにしています。47〜64行目で、上下左右の矢印キーが押されたときは `calc_force` を使用して世界座標のX・Y軸に沿って動くように設定し、A・Sキーが押されたときは力を直接設定して回転するようにしています。
68〜70行目でシミュレーションの毎周期で実行される_callback関数を定義しています。上で定義したロボットの角度を更新する関数とタイヤに力を設定する関数を呼んでいます。

### 自走式倒立振子

ここでは自走式倒立振子について紹介します。倒立振子は名前の通り振り子を逆さまにしたものです。これを倒立状態に保つというタスクが制御の例としてよく使用されます。自走式倒立振子はタイヤをつけ、現実世界で倒立振子を試すことができるようにしたものです。
以下の動画は動作例です。対称な構造をしており、そのままでは何もしなくても倒れないので、ランダムな外乱を加えています。また、左右の矢印キーで移動します。

![Inverted Pendulum](/images/mujoco-example/inverted_pendulum.gif)

モデルファイルを以下に示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/assets/inverted_pendulum.xml

4〜32行目でロボットの定義をしています。ボディ（7・8行目）、タイヤ（10〜22行目）、センサーマウント（23〜29行目）で構成されています。ボディに追従するカメラ（9行目）も定義しています。
34〜37行目ではアクチュエータの定義をしています。左右のタイヤを同期して動かすアクチュエータと倒立振子に外乱を加えるためのアクチュエータです。
39〜43行目ではセンサーを定義しています。2種類のセンサーがあり、1つ目はタイヤの回転量を取得するセンサーで倒立振子の位置を求めるために使用します。2つ目は、距離センサーで倒立振子の姿勢を求めるために使用します。詳細は後述します。

<!-- textlint-disable ja-spacing/ja-space-between-half-and-full-width -->

:::details 詳細な説明
7・8行目でボディを定義しています。
9行目はボディに追従するカメラを定義しています。
10〜22行目でタイヤを定義しています。今回は左右のタイヤを同期して動かすため、ボディに軸を取り付け、タイヤは軸に対して固定しています。
23〜29行目でセンサーマウントを定義しています。24行目はセンサーを設置するマウントを定義しています。25〜28行目で姿勢を求めるために使用する距離センサーを設置する場所を指定しています。ボディの前後に下向けで取り付け、床との距離を測ることで、ボディの傾きを求められます。
30行目は外乱を発生するためのアクチュエータを設置する場所を指定しています。
34〜37行目ではアクチュエータの定義をしています。35行目は軸を回転させるためのアクチュエータです。36行目は外乱を発生させるためのアクチュエータです。`gear="0.1 0 0 0 0 0"` とし、X軸方向＝倒立振子の前後方向に力を発生させます。
39〜43行目ではセンサーを定義しています。40行目は軸の回転量を計測するセンサーです。41・42行目は距離センサーで、最も近い面との距離が出力されます。
:::

<!-- textlint-enable ja-spacing/ja-space-between-half-and-full-width -->

以下に実行するPythonファイルを示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/src/inverted_pendulum.py

20〜23行目で使用する定数を定義しています。
27・28行目で倒立振子の姿勢の制御と位置の制御に使用するPIDコントローラを定義しています。パラメータはある程度動くよう、適当に決めています。
29行目では倒立振子の目標位置を初期化しています。
31〜40行目では倒立振子の姿勢を求める関数を定義しています。32・33行目で、前後の距離センサーの値を取得しています。距離センサーは先に物体がないと `-1` を返します。普通に動いていれば問題は発生しませんが、念の為34〜37行目で例外処理をしています。距離センサーの値と傾きの関係は以下の図のようになっており、この関係にしたがって39行目で傾きを計算します。`RF_DISTANCE` は前後の距離センサーの距離を表します。

![Attitude of Inverted Pendulum](/images/mujoco-example/inverted_pendulum_th.jpg)

42〜44行目では倒立振子の位置を求める関数を定義しています。タイヤが滑らないことを仮定し、回転量から移動量を計算します。
46〜54行目で左右の矢印キーが押された時の動作を定義しています。右を押されたときには目標位置を前に、左を押されたときには目標位置を後ろにします。そして、54行目でPIDコントローラの目標を更新します。
56〜65行目でシミュレーションの毎周期で実行される_callback関数を定義しています。57〜63行目で、姿勢と位置のそれぞれについてPIDコントローラで出力するトルクを求め、合算したものをMuJoCo側に渡しています。65行目では倒立振子に与える外乱をランダムに決定しています。

### ドローン

ここではドローンの実装について紹介します。以下の動画は動作例です。上下の矢印キーでドローンが上下に移動し、何もしていないときはその場で停止するようになっています。

![Drone](/images/mujoco-example/drone.gif)

モデルファイルを以下に示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/assets/drone.xml

4〜40行目でロボットの定義をしています。ボディ（13行目）、プロペラ（17〜27行目）で構成されています。ボディに追従するカメラ（16行目、上の動画では使用していない）も定義しています。
31〜36行目ではアクチュエータの定義をしています。今回は、簡略化のために、プロペラの中心に上向きの力を直接発生させています。
38〜40行目では速度センサーの定義をしています。MuJoCoではシミュレーションから得られるデータに全ての状態が含まれていますが、実際のロボット制御に少し寄せてセンサーから値を取得する方法を用いています。

<!-- textlint-disable ja-spacing/ja-space-between-half-and-full-width -->

:::details 詳細な説明
4〜8行目は[共通設定](#共通設定)のようにデフォルト設定を定義しています。ここでは、アクチュエータの定義を簡単にするための共通部分を定義しています。詳細はアクチュエータの箇所で述べます。
13〜14行目でボディの定義をしています。後々の制御の計算を楽にするため、`mass="1"` で質量を1kgに固定しています。
15行目はセンサーを取り付ける場所を定義しています。
16行目はボディに追従するカメラを定義しています。
17〜27行目でプロペラの定義をしています。 `replicate` を用いてz軸周りに-90度ずつ4回回転させることで、プロペラを配置しています。19〜20行目でボディとプロペラを繋ぐシャフト、23〜24行目でプロペラを定義しています。どちらも制御の計算を楽にするため、`mass=0` で質量を0に設定しています。また、21行目にはアクチュエータを設置する場所を定義しています。
31〜36行目でアクチュエータの定義をしています。アクチュエータのデフォルト設定で `gear="0 0 1 0 0 0"` を設定しており、Z軸正方向（上向き）に力が発生します。`ctrlrange="0 5"` として下向きに力が発生しないようにもしています。`site` で力を発生させる場所を指定します。replicateでは中のnameに自動で番号を振るので、`site=thrust0` のように指定しています。
38〜40行目では速度センサーの定義をしています。
:::

<!-- textlint-enable ja-spacing/ja-space-between-half-and-full-width -->

以下に実行するPythonファイルを示します。

https://github.com/maki8maki/MuJoCoExample/blob/main/src/drone.py

20〜23行目で共通して使用する定数を定義しています。STABLE_FORCEはドローンがその場で留まるために1つのプロペラが出すべき力を表しています。
30行目で制御に使用するPIDコントローラーを定義しています。[simple-pid](https://simple-pid.readthedocs.io/en/latest/)を使用しています。パラメータは適当に決めています。
32〜34行目で力を入力するユーティリティ関数を定義しています。
37〜44行目で上下の矢印キーが押された時の動作を定義しています。上下方向の目標加速度を出すための力にSTABLE_FORCEを足したものを出力すべき力としています。それ以外の場合では `self.hovering = true` とし、その場で留まるように制御します。これは次で述べます。
49〜57行目でシミュレーションの毎周期で実行される_callback関数を定義しています。`self.hovering = true` の場合は、センサーから取得したZ方向の速度がゼロになるようにPID制御しています。そうでない場合は、PIDコントローラーの中身をリセットするだけで、上で計算した力をそのまま使用します。

## おわりに

この記事では簡易化したモデルでMuJoCoの実装例を紹介しました。より現実に近いロボットを使用したい場合は、公式ドキュメントの[モデルギャラリー](https://mujoco.readthedocs.io/en/stable/models.html)に掲載されているので参考にしてみてください。

## 参考

* [MuJoCo公式ドキュメント](https://mujoco.readthedocs.io/en/stable/overview.html)
* [【Python】物理エンジンMuJoCoの紹介＆MJCFドキュメント【MuJoCoチュートリアル①】](https://qiita.com/Yayoi-Habami/items/1bf5a3e05b1516a90381)のシリーズ
* [簡単！実践！ロボットシミュレーション](https://www.morikita.co.jp/books/mid/084691)
  * ODEでの実装例は[GitHub](https://github.com/demuko/ode_book/tree/master)上にある
